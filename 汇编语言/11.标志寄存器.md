## 标志寄存器

CPU内部的寄存器中，有一种特殊的寄存器，具有以下三种作用

1. 用来存储相关指令的某些执行结果

2. 用来为CPU执行相关指令提供行为依据

3. 用来控制CPU的相关工作方式

flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的。也就是说，每一位都有专门的含义，记录特定的信息



8086CPU的flag结构

15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0

            OF DF IF TF SF ZF    AF    PF    CF

|标志|值为1的标记|值为0的标记
|---|---|---|
|OF|OV|NV|
|SF|NG|PL|
|ZF|ZR|NZ|
|PF|PE|PO|
|CF|CY|NC|
|DF|DN|UP|

对应当前指令之后的结果，也就是说会随着每一条命令的执行而改变
### 11.1ZF标志

ZF(零标志位),它记录相关指令执行后，结果位0，ZF=1

    mov ax,1
    sub ax,1

### 11.2PF标志

PF(奇偶标志位),它记录相关指令执行后，结果所有的bit位中1的个数位偶数，PF=1

    mov ax,1
    or al,10

### 11.3SF标志

SF(符号标志位),它记录相关指令执行后，结果为负，SF=1

    mov ax,1
    or al,10

### 11.4CF标志

SF(进位标志位),它记录相关指令执行后，一般情况下，在进行无符号数运算的时候，它记录了最高位向更高位的进位值，或从更高位的借位值

    mov ax,1
    or al,10

### 11.5 OF标志位

在进行有符号位的运算，超出了机器所能表达的范围会产生移除的问题

### 11.6 adc指令

带进位加法指令，它利用了CF位上记录的进位值

指令格式:adc 操作对象1,操作对象2
功能: 操作对象1= 操作对象1+操作对象2+CF

编程任务:计算1FF000h+4FF000h

    mov ax,1F00H
    mov bx,0F000H
    add bx,F000H
    adx ax,004FH

### 11.7sbb指令

带借位减法指令，它利用CF位上记录的借位值

指令格式:adc 操作对象1,操作对象2
功能: 操作对象1= 操作对象1-操作对象2-CF

### 11.8cmp指令

比较指令，相当于减法指令，只是不保存结果

指令格式:adc 操作对象1,操作对象2
功能: 操作对象1= 操作对象1-操作对象2,但不保存结果,仅根据计算结果对标志寄存器进行设置

注意如果SF=1，不足以说明操作数1<操作数2。如果因为溢出，导致结果为负，则逻辑上真正的结果为正。必须要同时考虑OF

1. SF=1,OF=0    <
2. SF=1,OF=1    >
3. SF=0,OF=1    <
4. SF=0,OF=0    >=

### 11.9检测比较结果的条件转移指令

|指令|含义|检测的相关标志
|---|---|---|
|je|等于|ZF=1|
|jne|不等于|ZF=0|
|jb|低于|CF=1|
|jnb|不低于|CF=0|
|ja|高于|CF=0,ZF=0|
|jna|不高于|CF=1或ZF=1|


练习

        cmp ah,bh
        jes
        add ah,bh
        jmp short ok
    s:  add ah,ah
    ok: ret

    相当于if(ah=bh){ah=ah+ah}else{ah=ah+bh}

#### 11.10DF标志和串传送指令

flag的第10位DF，是方向标志位。在串处理指令中，控制每次操作后si和di的增减

格式: movsb/wovsw(+2)
功能:相当于执行以下几步
1. ((es)*16+(di))=((ds)*16+(si))
2. 如果df=0，则(si)=(si)+1,(di)=(di)+1,否则(si)=(si)-1,(di)=(di)-1

8086CPU提供两条指令对DF进行设置

- cld:DF为0
- std:DF为1

问题：实现把F000段中的最后16位字符复制到data段中

    mov ax,0f000H
    mov ds,ax
    mov si,ffffh
    mov ax,data
    mov es,ax
    mov di,15
    mov cx 16
    std
    rep movsb
    ;ds:si=es:di,di+16指向后面的空间
### 11.11pushf和popf

pushf:将标志寄存器的值压栈
popf:从栈中弹出数据送入标志寄存器

    mov ax,0
    push ax
    popf 0
    ;0000 0000 0000 0000b
    mov ax,0ffff0h
    add ax,0010h
    ;CF,PF,ZF,SF都为1
    pushf
    pop ax
    and al,11000101B
    and ah,00001000B


    ;(ax) = 01000101B

